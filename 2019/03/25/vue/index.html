<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>vue | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Vue：跟着14篇教程，从零开始做一个todos应用看了些文档，感觉到了vue的一些特点，感觉它肯定是非常方便非常有用的，奈何基础薄弱，让自己实际运用还是会很云里雾里的。还是先跟着教程走一走麻雀的五脏，加深一下理解。同时希望多用markdown。">
<meta name="keywords" content="first">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="http://xghijk.github.io/hexo/2019/03/25/vue/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Vue：跟着14篇教程，从零开始做一个todos应用看了些文档，感觉到了vue的一些特点，感觉它肯定是非常方便非常有用的，奈何基础薄弱，让自己实际运用还是会很云里雾里的。还是先跟着教程走一走麻雀的五脏，加深一下理解。同时希望多用markdown。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-27T16:03:52.761Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue">
<meta name="twitter:description" content="Vue：跟着14篇教程，从零开始做一个todos应用看了些文档，感觉到了vue的一些特点，感觉它肯定是非常方便非常有用的，奈何基础薄弱，让自己实际运用还是会很云里雾里的。还是先跟着教程走一走麻雀的五脏，加深一下理解。同时希望多用markdown。">
  
    <link rel="alternate" href="/hexo/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/hexo/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/hexo/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/hexo/">Home</a>
        
          <a class="main-nav-link" href="/hexo/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/hexo/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xghijk.github.io/hexo"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexo/2019/03/25/vue/" class="article-date">
  <time datetime="2019-03-25T04:57:06.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      vue
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue：跟着14篇教程，从零开始做一个todos应用"><a href="#Vue：跟着14篇教程，从零开始做一个todos应用" class="headerlink" title="Vue：跟着14篇教程，从零开始做一个todos应用"></a>Vue：跟着14篇教程，从零开始做一个todos应用</h1><p>看了些文档，感觉到了vue的一些特点，感觉它肯定是非常方便非常有用的，奈何基础薄弱，让自己实际运用还是会很云里雾里的。还是先跟着教程走一走麻雀的五脏，加深一下理解。同时希望多用markdown。<a id="more"></a>原教程：<a href="https://juejin.im/post/5c3e9f946fb9a049f06a85ff" target="_blank" rel="noopener">https://juejin.im/post/5c3e9f946fb9a049f06a85ff</a> </p>
<h2 id="入门仪式：Hello-Vue"><a href="#入门仪式：Hello-Vue" class="headerlink" title="入门仪式：Hello Vue"></a>入门仪式：Hello Vue</h2><h3 id="Hello-Vue"><a href="#Hello-Vue" class="headerlink" title="Hello Vue"></a>Hello Vue</h3><p>既然是学习编程，那就遵循一下那个古老的传统仪式。</p>
<p>首先我们新建一个 todos.html 文件，用任何一个你喜欢的文本编辑器或者 IDE 打开（例如 vscode、sublime、记事本、notepad++、webstorm 等等），然后写上下面的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Todo Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.5.16/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el: '#app',</span></span><br><span class="line"><span class="undefined">        data: function () &#123;</span></span><br><span class="line"><span class="undefined">            return &#123;message: 'Hello Vue!'&#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们写了一个简单的 HTML 文件，使用 Script 标签引入了 Vue，版本是 2.5.16。然后我们写了几行 js 代码。在代码中我们 new（创建） 了一个 Vue 对象，并向这个对象传递了一些选项，例如告诉 Vue 挂载的元素（el，即elements 的缩写）是 <code>id</code> 为 <code>app</code> 的那个 <code>div</code>，并且在 <code>data</code> 中绑定了一个名为 <code>message</code> 的变量，其值为 ‘Hello Vue!’，然后我们就可以在 HTML 文档中引用这个 <code>message</code> 。Vue 在后面帮我们做么很多神奇的事情，它把 <code></code> 替换成了 Vue 对象中对应的值。</p>
<p>保存代码并用浏览器打开，可以看到浏览器显示了 “Hello Vue!”，你也可以尝试修改 message 的值，发现显示的内容会跟着变化。</p>
<h3 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h3><p>再来看一个神奇的例子，我们把代码换成下面这样： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Todo Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>value 的值是：&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.5.16/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el: '#app',</span></span><br><span class="line"><span class="undefined">        data: function () &#123;</span></span><br><span class="line"><span class="undefined">            return &#123;value: ''&#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里要关注一下文档的 input 标签里 <code>v-model=&quot;value&quot;</code> 这个东西。<code>v-model</code> 被称为 Vue 的指令，指令可以用来做很多事，比如用于 if 条件判断的 v-if，用于绑定值的 v-bind、用于绑定监听事件的 v-on 等等，这在以后会接触到。而这个 v-model 指令的作用是将 input 元素 value 属性的值和我们创建的 Vue 对象中 value 的值进行绑定，我们知道 input 有一个 value 属性，它的值会在浏览器显示（例如后面那个 button 按钮的<strong>发送</strong>），Vue 将这个值绑定后，在 input 中引起的 value 值变化就会实时反映到关联的 Vue 对象，所以会看到下方引用的  也会跟着变化。</p>
<p>打开浏览器，然后在文本框做一些输入，试试效果！</p>
<h3 id="加点方法"><a href="#加点方法" class="headerlink" title="加点方法"></a>加点方法</h3><p>接下来我们在 Vue 对象中加点方法，还是上面的例子，只是在 Vue 对象中加了一个方法： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">        el: '#app',</span><br><span class="line">        data: function () &#123;</span><br><span class="line">            return &#123;value: ''&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 这是新增的方法</span><br><span class="line">        methods: &#123;</span><br><span class="line">            send: function () &#123;</span><br><span class="line">                alert('发送成功！');</span><br><span class="line">                this.value = ''</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>方法声明在 method 对象中，key 为方法名，值为对应的函数。我们想做的事情很简单，就是点击发送按钮后显示一个发送成功的消息，然后将 value 的值清空。</p>
<p>打开浏览器，发现怎么点都没有效果！因为 Vue 并不知道我们点击了按钮，为了让 Vue 监听到我们点击按钮的事件，需要在被点击的元素上绑定一个 click 事件，前面说过绑定事件用 v-on，因此在发送按钮上加上相应的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送"</span> <span class="attr">v-on:click</span>=<span class="string">"send"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在输入框输入一些文字，然后点击发送按钮试试。 </p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>Vue 还可以根据绑定的数据做一些计算，然后我们就可以引用计算的结果。假设我们想实时统计输入的字数，我们可以在 Vue 对象里加上对 value 长度的计算值： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">        el: '#app',</span><br><span class="line">        data: function () &#123;</span><br><span class="line">            return &#123;value: ''&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            // 省略...</span><br><span class="line">        &#125;,</span><br><span class="line">        // 这是新增的计算属性</span><br><span class="line">        computed: &#123;</span><br><span class="line">            count: function () &#123;</span><br><span class="line">                return this.value.length</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>计算属性申明到 computed 对象里，这个对象的键是计算的结果，值是计算函数，这里我们计算了 value 的长度。以后在 Vue 对象中就可以使用 this.count 引用计算结果，也可以在关联的模板中直接引用，和绑定的数据 value 的用法非常类似。比如我们在文档中引用这个 count： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送"</span> <span class="attr">v-on:click</span>=<span class="string">"send"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>value 的值是：&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引用 count --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>字数：&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开浏览器看看效果。 </p>
<h3 id="加点样式"><a href="#加点样式" class="headerlink" title="加点样式"></a>加点样式</h3><p>Vue 还可以动态地帮我们为元素绑定样式（class 属性），假设如果我们希望 input 中没有任何值输入，即 value 的值为空时，input 的边框为红色以提醒用户没有内容。首先我们写一个简单的样式（这个样式非常简单，不需要有 CSS 基础也看得懂），样式通常写到 head 标签里，用 style 包裹： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Todo Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .empty &#123;</span></span><br><span class="line"><span class="undefined">      border-color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后将这个 empty 用于 input 的 class 属性，浏览器就会渲染对应的样式： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">'empty'</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然现在无论 value 为何值边框都是红色的，因为 class 始终为 empty，现在让 Vue 来帮我们。前面说了，绑定值用 v-bind 指令，我们修改一下代码，为 input 的 class 绑定一个值： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">v-bind:class</span>=<span class="string">'&#123;empty: !count&#125;'</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Vue 会根据 empty 后的表达式 !count 的真假来判断 class 的值是否为 empty，如果为真（即 count = 0 的情况），则 class 的值为 empty，否则为空。</p>
<p>打开浏览器看看效果！</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>我们通过这几个循序渐进的例子体会了 Vue 的部分核心特性，这些特性对我们开发 Todo 应用非常有帮助。当然这个例子还有一点小瑕疵，就由你来作为练习改进一下。</p>
<p><strong>练习一：</strong>尽管我们在用户没有输入时用红色边框提醒用户内容为空，但是用户点击按钮后任然显示提交成功的通知，这是不合理的。合理的情况应该是弹出通知提示用户请输入内容。修改示例的代码，使其达到上述效果。（提示：修改 <code>send</code> 方法）</p>
<p><strong>练习二：</strong>即使内容为空，输入框下方依然显示 <em>value 的值是：</em>，这看起来很奇怪。我们希望只有用户真正地输入了内容后，才提示 value 的值，请参阅 Vue 关于指令的官方文档，找到满足我们需求的指令，修改示例代码以达到上述效果。（提示：我们应该通过判断 value 是否有值来决定是否显示输入框下边的 div 元素。）</p>
<p>Vue 的指令文档：<a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/conditional.html</a></p>
<p>答案：练习一：修改send</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	send:function()&#123;</span><br><span class="line">		if(!this.count)&#123;alert("请先输入内容！")&#125;</span><br><span class="line">		else&#123;alert("发送成功！");this.value=""&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习二：使用命令v-if</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"count"</span>&gt;</span>value 的值是：&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来正式开始我们的 Todo 应用的开发吧！ </p>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>我们先来写好 Todo 应用的 HTML 文档模板，然后再用 Vue 来操作模板中的数据。由于我们采用了极简风格设计，因此可以看到模板的代码量非常少，如果加入过多的 CSS 样式，在教程中代码看起来就非常乱了。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Todo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .completed &#123;</span></span><br><span class="line"><span class="undefined">      text-decoration: line-through;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .selected &#123;</span></span><br><span class="line"><span class="undefined">      color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"全部标为完成"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"添加 todo"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- todo list --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"completed"</span>&gt;</span>学习 Vue<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"标为完成"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"删除"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"编辑 todo..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>整个牛项目<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"标为完成"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"删除"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"编辑 todo..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>迎娶白富美走上人生巅峰<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"标为完成"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"删除"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"编辑 todo..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- end todo list --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>剩余 3 项未完成 ---<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>筛选：</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"全部"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"进行中"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"已完成"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"清除已完成"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"清除全部"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请复制上述代码到一个 html 文件然后使用浏览器打开，你就可以看到界面了。</p>
<p>不过目前还只有 UI，我们将使用 Vue 实现完整的功能列表如下：</p>
<ul>
<li>在顶部输入框输入内容，按回车键添加 todo</li>
<li>全部 todo 列表显示在输入框下方的列表</li>
<li>可将单个 todo 标为完成</li>
<li>可删除单个 todo</li>
<li>双击 todo 进行编辑，按 esc 键取消编辑</li>
<li>下方显示未完成的 todo 数量</li>
<li>可通过筛选按钮筛选未完成的 todo、已完成的 todo 等</li>
<li>可一次性将全部 todo 标为完成，可一次性清除全部已完成 todo，或者一次性清除全部 todo。</li>
<li>其它更加丰富的功能…</li>
</ul>
<p>接下来就让我们一个一个以 Vue 的方式来实现它们吧！</p>
<h2 id="显示todo列表"><a href="#显示todo列表" class="headerlink" title="显示todo列表"></a>显示todo列表</h2><p>在我们的当前模板中，todo 列表的值都是我们直接写在 HTML 文档里的。合理的情况应该是根据用户添加和删除 todo 时动态地显示全部内容，这就要交给 Vue 了。当然，第一步是要先构建 Vue 的实例，注意这个实例目前是没有绑定任何数据的，其 data 是一个空函数，不返回任何有用的数据： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-app"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.5.16/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el: '#todo-app',</span></span><br><span class="line"><span class="undefined">        data: function () &#123;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们现在还没有实现用户添加 todo 的功能，我们先做个弊，假设用户已经输入了一些 todo，存在一个 todos 列表里，现在需要将 Vue 实例和这个 todos 绑定： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: '#todo-app',</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            todos: [</span><br><span class="line">                &#123;id: 0, title: '学习 Vue'&#125;,</span><br><span class="line">                &#123;id: 1, title: '整个牛项目'&#125;,</span><br><span class="line">                &#123;id: 2, title: '迎娶白富美走上人生巅峰'&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在每一个 todo 都是一个对象，它有 id 和 title 两个属性，id 用来唯一标识这个 todo。然后我们就在模板中循环显示这个 todos 列表，Vue 中循环指令用 v-for： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-app"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--todo list--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'todo in todos'</span> <span class="attr">:key</span>=<span class="string">'todo.id'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; todo.title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"标为完成"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"删除"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"编辑 todo..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- end todo list --&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到 <code>v-for=&#39;todo in todos&#39;</code> 这种写法，其含义就是循环 todos 列表，将列表的每一项保存到 todo 变量，循环渲染 li 元素的内容。特别注意我们还给 li 元素绑定了一个 key 属性，这将告诉 Vue 每个渲染的 li 元素都是不同的，因为 id 不同。</p>
<p>你可以删除或者添加 todos 列表中的元素，然后刷新浏览器，可以看到页面渲染的内容会跟着变化。你也可以在按 F12 进入浏览器的调试窗口，在命令行（console）输入命令：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.todos = [</span><br><span class="line">                &#123;id: 1, title: '整个牛项目'&#125;,</span><br><span class="line">                &#123;id: 2, title: '迎娶白富美（或走上人生巅峰）'&#125;,</span><br><span class="line">            ]</span><br></pre></td></tr></table></figure>
<p>这个 app 是我们创建的 Vue 实例的名字，然后引用它绑定的数据 todos，我们给它赋了一个新的值，然后你会实时地看到浏览器渲染的结果变化了。Vue 就是这么神奇！</p>
<p>显然，人工为 todos 列表添加数据是一点也不好玩的，我们希望在上方的输入框输入想要添加的 todo，然后按回车就自动给我们添加 todo，接下来我们就来实现它。</p>
<h2 id="添加todo"><a href="#添加todo" class="headerlink" title="添加todo"></a>添加todo</h2><p>在教程的第一篇 <a href="https://www.zmrenwu.com/post/63/" target="_blank" rel="noopener">入门仪式：Hello Vue</a> 中我们演示了一个 Vue 绑定 input 输入值的示例，添加 todo 的功能和那个例子有异曲同工之妙。</p>
<p>为了知道用户输入了什么内容，我们使用 v-model 指令将 input 的 value 值和 Vue 的实例绑定，这样在 Vue 中我们就知道了用户输入的值。然后我们监听用户按下回车的事件，一旦这个事件被触发，我们就在 Vue 实例中调用相应的方法，把新的值添加到 todos 列表中，下面来一步步完成上面的步骤。</p>
<p>绑定 input 的输入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-app"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"添加 todo"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">v-model</span>=<span class="string">"newTodoTitle"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el: '#todo-app',</span></span><br><span class="line"><span class="undefined">        data: function () &#123;</span></span><br><span class="line"><span class="undefined">            return &#123;</span></span><br><span class="line"><span class="undefined">                todos: [],</span></span><br><span class="line"><span class="undefined">                newTodoTitle: ''</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们把预先填充在 todos 列表的值清空了，因为一开始是没有 todo 的。然后我们使用 v-model 指令将 input 的 value 属性的值与 Vue 实例的 newTodoTitle 值绑定。注意这里绑定的数据可以取任何名字，不一定要和 input 的属性 value 相同。</p>
<p>然后我们监听键盘敲击回车的事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-app"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"添加 todo"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-model</span>=<span class="string">"newTodoTitle"</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">keyup.enter</span>=<span class="string">"addTodo"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el: '#todo-app',</span></span><br><span class="line"><span class="undefined">        data: function () &#123;</span></span><br><span class="line"><span class="undefined">            return &#123;</span></span><br><span class="line"><span class="undefined">                todos: [],</span></span><br><span class="line"><span class="undefined">                newTodoTitle: ''</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到 <a href="mailto:`@keyup.enter" target="_blank" rel="noopener">`@keyup.enter</a>=”addTodo”`，我们之前的示例中绑定过 click 事件，绑定键盘按键的事件为 keyup，然后我们使用 enter 对事件进行修饰，表明这个事件是按下回车，而不是按下别的什么键。Vue为按键提供了很多修饰符，可以参考 Vue <a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按键修饰符</a>的官方文档。事件绑定后，一旦用户按下回车，就会调用后边的 addTodo 方法。</p>
<p>实现 addTodo 方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    let id = 0; // 用于 id 生成</span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        ...</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="undefined">            addTodo: function () &#123;</span></span><br><span class="line"><span class="undefined">                this.todos.push(&#123;id: id++, title: this.newTodoTitle&#125;);</span></span><br><span class="line"><span class="undefined">                this.newTodoTitle = ''</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例中已经说过方法声明在 Vue 对象的 methods 属性里。这个 addTodo 方法做的事情很简单，生成一个新的 todo 对象，然后将其添加到 todos 列表里（push 方法就是把一个元素加入到数组的末尾），然后将用户的输入值清空。始终注意这里 newTodoTitle 和输入框的 value 值是双向绑定的，任何一个值改变，相应的值都会跟着变。</p>
<p>打开浏览器，试着添加几个 todo 吧！</p>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p><strong>练习一：</strong>我们的方法有一个小 bug，如果用户什么内容也没有输入，但是敲下了回车，我们的应用会为其创建一个空的 todo，正确的效果应该是不做任何动作。尝试修改程序，实现正确的效果。</p>
<p><strong>练习二：</strong>能否进一步地，当用户尝试创建空的 todo 时，我们的输入框边框变红色，提醒用户没有任何内容输入，以及在输入框后边显示“请输入内容”之类的提示信息呢？（hint：结合之前示例中给出的计算属性、动态绑定 class、v-if 指令来实现，你可能需要参考 Vue 的官方文档了解这些内容）。</p>
<p>涉及的官方文档：</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">计算属性</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/class-and-style.html" target="_blank" rel="noopener">Class 与 Style 绑定</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">v-if 条件渲染</a></li>
</ul>
<p>答案 ：练习一</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">                addTodo: function () &#123;</span><br><span class="line">                    if (!this.newTodoTitle) &#123;</span><br><span class="line">                        alert("请输入内容！")</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        this.todos.push(&#123; id: id++, title: this.newTodoTitle &#125;);</span><br><span class="line">                        this.newTodoTitle = ""</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>练习二：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    todos: [],</span><br><span class="line">                    newTodoTitle: "",</span><br><span class="line">                    emptyChecked: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                addTodo: function () &#123;</span><br><span class="line">                    if (!this.newTodoTitle) &#123;</span><br><span class="line">                        this.emptyChecked = true;</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        this.todos.push(&#123; id: id++, title: this.newTodoTitle &#125;);</span><br><span class="line">                        this.newTodoTitle = "";</span><br><span class="line">                        this.emptyChecked = false</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"添加todo"</span> <span class="attr">v-model</span>=<span class="string">"newTodoTitle"</span> @<span class="attr">keyup.enter</span>=<span class="string">"addTodo"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;emptyStyle:emptyChecked&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span> = <span class="string">"emptyChecked"</span> <span class="attr">style</span> = <span class="string">"color:red"</span>&gt;</span>请输入内容！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="标为完成"><a href="#标为完成" class="headerlink" title="标为完成"></a>标为完成</h2><p>用户点击标为完成按钮，则将对应的 todo 标为完成，为了标记 todo 是已完成还是未完成的状态，我们需要稍微改造一下我们的 todo 模型，一开始我们的 todo 有 id、title 两个属性，现在加一个 completed 属性，默认值是 false，表示未完成。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo = &#123;id:1, title:'todo', completed:false&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们对应的 addTodo 方法也要修改一下： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addTodo: function () &#123;</span><br><span class="line">    this.todos.push(</span><br><span class="line">        // 修改后的 todo 模型</span><br><span class="line">        &#123;id: id++, title: this.newTodoTitle, completed: false&#125;</span><br><span class="line">    );</span><br><span class="line">    this.newTodoTitle = '';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标为已完成的思路和之前是一样的，监听用户点击标为完成按钮的 click 事件，然后调用相应的处理方法，把 todo 的 completed 的属性由 false 改为 true 即可。这里的一个关键是，我们如何知道用户点击的是哪一个 todo，或者说我们可以通过坐在用户身边的方式用肉眼观察用户点击了哪个 todo，但是 Vue 如何知道？</p>
<p>好在 Vue 允许我们向绑定的方法传递参数，我们可以把当前循环中 todo 的对象传给绑定的方法，绑定的方法代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-app"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--todo list--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'todo in todos'</span> <span class="attr">:key</span>=<span class="string">'todo.id'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; todo.title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">value</span>=<span class="string">"标为完成"</span></span></span><br><span class="line"><span class="tag">             @<span class="attr">click</span>=<span class="string">"markAsCompleted(todo)"</span>/&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- end todo list --&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到我们给标为完成的按钮的点击事件绑定了一个 markAsCompleted 方法，这个方法将用来处理将 todo 标为完成的动作。同时和之前绑定的的方法不同的是，我们还给他传递了一个参数，其值为 todo，这个 todo 是我们在 v-for=’todo in todos’ 获取，当前循环的是哪个 todo，这个 todo 就指向哪个 todo 对象。从而 Vue 就知道了原来我们我们想要操作 todos 列表中这个 todo 对象。</p>
<p>markAsCompleted的逻辑非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    ...</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addTodo: function () &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        markAsCompleted: function (todo) &#123;</span><br><span class="line">            todo.completed = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>视觉上我们应该让已经标记了已完成的 todo 显示为已删除的状态，一条横线穿过。这需要为我们的内容增加一点样式，这又要用到我们动态绑定样式的方法了： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">    &lt;span :class=&quot;&#123;completed: todo.completed&#125;&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;标为完成&quot;</span><br><span class="line">           @click=&quot;markAsCompleted (todo)&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>这个completed 的样式我们定义在html文档最开头的head标签的style标签里，为元素提供贯穿线的样式。这里根据 todo.completed 来决定是否应该给元素添加 class=‘completed’ 的样式。 </p>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p><strong>练习一：</strong>目前我们点击标为完成按钮后，这个按钮是不会消失的，为了更好的用户体验，已完成的 todo 后面不该再显示一个标为完成的按钮了，想办法把它去掉。</p>
<p><strong>练习二：</strong>进一步地，如果用户突然发现其实事情还没有做完，他想把这个 todo 标记回未完成状态，添加一个标为未完成的按钮实现这个需求，要注意不同按钮出现的场合应该符合逻辑。</p>
<p>答案 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;标为完成&quot; @click=&quot;markAsCompleted(todo)&quot; v-if=&quot;!todo.completed&quot;&gt;</span><br><span class="line">               &lt;input type=&quot;button&quot; v-if=&quot;todo.completed&quot; value=&quot;取消标记&quot; @click=&quot;deleteMark(todo)&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deleteMark: function(todo)&#123;</span><br><span class="line">                    todo.completed = false</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除todo"><a href="#删除todo" class="headerlink" title="删除todo"></a>删除todo</h2><p>有了之前的基础，删除 todo 的功能变得易如反掌，我们只需要监听用户点击删除按钮的事件，绑定一个删除 todo 的方法，将当前需要删除的 todo传给 vue，vue 就知道我们要删除哪个 todo了。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'todo in todos'</span> <span class="attr">:key</span>=<span class="string">'todo.id'</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"删除"</span> @<span class="attr">click</span>=<span class="string">"removeTodo(todo)"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    let id = 0; // 用于 id 生成</span></span><br><span class="line"><span class="undefined">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        ...</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="undefined">            ...</span></span><br><span class="line"><span class="undefined">            removeTodo: function (todo) &#123;</span></span><br><span class="line"><span class="undefined">                this.todos.splice(this.todos.indexOf(todo), 1)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里用到两个 JavaScript 数组的相关方法，this.todos.indexOf(todo) 用来定位元素的位置，然后我们删除掉这个位置的元素 splice(index, 1)，1 表示只删除一个，即当前位置（index 的值）的元素。</p>
<p>由于 todos 是一个数组，所以我们这里将大量涉及 js 的数组操作，不妨浏览一下 js 数组都有哪些方法可以为我们所用。</p>
<h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><p><strong>练习一：</strong>我们现在的删除操作非常粗暴，只要一点击 todo 就彻底消失了。能否温和一点，让用户点击删除时并非真正地删除，而是弹出一个提示框，提示用户确定删除这个 todo 么？用户可以确认也可以取消。</p>
<p><strong>练习二：</strong>还有一种温和的删除方式，用户点击删除不会提示，但是删除后会出现一个撤销按钮，允许用户撤销当前的删除操作，点击撤销后之前删除的 todo 又回来了。</p>
<p>更进一步，我们为用户提供一个回收站功能，里面记录用户的全部已删除 todo，用户可以还原删除的 todo。（hint：这个功能等讲到我们实现 todo 的筛选后就知道如何做了，目前不妨先思考一下。）</p>
<p>我的答案：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"isRemove"</span>&gt;</span>确定要删除吗？<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"确定"</span> @<span class="attr">click</span>=<span class="string">"sureRemoveTodo(todo)"</span> <span class="attr">v-if</span>=<span class="string">"isRemove"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isRemove: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">removeTodo: function()&#123;</span><br><span class="line">                    this.isRemove = true;</span><br><span class="line">                &#125;,</span><br><span class="line">                sureRemoveTodo: function(todo)&#123;</span><br><span class="line">                    this.todos.splice(this.todos.indexOf(todo), 1)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>答案：<strong>练习一</strong></p>
<p>javascript 有一个 confirm 方法，调用该方法浏览器会弹出一个确认框，用户点击确认该方法会返回 true，点取消则不返回 true，因此用该方法可以实现我们的功能，只需修改 removeTodo 方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">removeTodo: function (todo) &#123;</span><br><span class="line">    if (!confirm(&apos;确认删除？&apos;)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    this.todos.splice(this.todos.indexOf(todo), 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即如果用户没有点击确认，则 if 语句会执行，函数直接返回，不做删除操作。</p>
<p><strong>练习二</strong></p>
<p>这个功能的基本思路是，当用户删除某个 todo 后，我们用一个变量将这个删除的 todo 暂时保存下来，如果用户点击了撤销按钮，就把这个暂存的 todo 再插回原来的 todo 列表。为此，我们先给 vue 增加一个 removedTodo 变量，其初始值为 null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        todos: [],</span><br><span class="line">        newTodoTitle: &apos;&apos;,</span><br><span class="line">        removedTodo: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果用户点击了删除 todo 按钮，就把这个删除的 todo 保存到 removedTodo 变量，修改一下 removeTodo 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">removeTodo: function (todo) &#123;</span><br><span class="line">    let pos = this.todos.indexOf(todo);</span><br><span class="line">    this.removedTodo = &#123;</span><br><span class="line">        pos: pos,</span><br><span class="line">        todo: this.todos.splice(pos, 1)[0]</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>注意这里我们先获取了被删除的 todo 在 todo 列表的位置 pos，这个 pos 的作用是记录被删除 todo 的位置，撤销时我们就可以根据这个位置将被删除的 todo 插回原始位置。removedTodo 记录了位置信息和被删除的整个 todo。注意 this.todos.splice(pos, 1) 返回被删除的元素，即使只有一个元素，返回的也是数组，因此我们取索引 0 位置的元素。</p>
<p>让后我们给页面添加一个撤销按钮，该按钮监听点击事件并调用 restoreTodo 方法撤销删除操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    restoreTodo: function () &#123;</span><br><span class="line">        let pos = this.removedTodo.pos;</span><br><span class="line">        let restored = this.removedTodo.todo;</span><br><span class="line">        this.todos.splice(pos, 0, restored);</span><br><span class="line">        this.removedTodo = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>代码很好理解，注意这里 splice 方法第二个参数为 0 表示在数组的指定位置（pos）插入元素。撤销后别忘了将 removedTodo 重新置为 null。</p>
<p>然后加一个按钮，绑定 restoreTodo 的 click 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- todo list --&gt;</span><br><span class="line">&lt;div v-if=&quot;hasRemovedTodo&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;撤销&quot; @click=&quot;restoreTodo()&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">...</span><br><span class="line">&lt;!-- end todo list --&gt;</span><br></pre></td></tr></table></figure>
<p>要注意这里我们用 v-if 指令来条件渲染撤销按钮，因为只有当存在被删除的 todo 时，按钮才需要被渲染，如何判断是否存在被删除的 todo 呢，可以根据 removedTodo 是否为 null 来判断，是则没有，否则就有，为此我们创建一个计算属性 hasRemovedTodo 来指示是否存在被删除的 todo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    hasRemovedTodo: function () &#123;</span><br><span class="line">        return !!this.removedTodo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>撤销拓展</strong></p>
<p>上面我们实现的撤销功能只记录了最近被删除的 todo，如果你连续删除多个 todo，只有最近被删除的 todo 能还原。为了支持多个 todo 还原，我们可以把 removedTodo 这个变量设置为一个栈，每删除一个 todo 就将被删除的 todo 压入栈中，点击撤销则弹出栈顶的 todo 还原，从而实现多步撤销功能。该功能不再实现，留给你作为拓展练习。</p>
<h2 id="编辑todo"><a href="#编辑todo" class="headerlink" title="编辑todo"></a>编辑todo</h2><p>编辑 todo 的功能略微有点复杂，我们一点点来分解。</p>
<p>首先根据之前的分析，Vue 很容易知道我们想要编辑的是哪一个 todo，只要把当前的 todo 传给绑定的方法即可。我们实现的功能是双击当前的 todo 进入编辑状态，我们就可以在后边的输入框编辑这个 todo，因此需要给元素绑定一个双击监听事件。还有一点需要注意，我们有一个取消编辑的功能，假设用户将 todo 编辑到了一半又不想编辑了，想回到原来的 todo 内容，我们该怎么办？为了解决这个问题，我们可以在 data 返回的对象添加一个属性，让它来暂存编辑前的 todo 状态，如果用户取消了编辑，就让已修改的 todo 退回到之前的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">        el: &apos;#todo-app&apos;,</span><br><span class="line">        data: function () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                todos: [],</span><br><span class="line">                newTodoTitle: &apos;&apos;,</span><br><span class="line">                editedTodo: null // 用于暂存编辑前的 todo 状态</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>另一个问题是后面那个编辑框十分烦人，因为无论我们是否在编辑状态，这个框始终出现。应该根据当前的 todo 是否处于编辑状态来决定它的出现与否，只有当用户双击 todo 进入编辑状态时才出现，那么怎么知道这个 todo 是否是处于当前状态呢？</p>
<p>我们之前在 data 返回的对象里增加了一个 editedTodo 属性，并且把它的初始值设为 null，这个属性的用途是用来暂存编辑前的 todo 状态的，即当用户编辑某个 todo 时，这个 editedTodo 就会被设置为当前 todo 未被编辑前的值。换句换说，如果 editedTodo 为 null，则一定说明这个 todo 不在编辑状态。所以我们可以根据 editedTodo 的值来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;input type=&quot;text&quot; </span><br><span class="line">               value=&quot;编辑 todo...&quot;</span><br><span class="line">               v-if=&quot;editedTodo !==null&quot;/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>然后我们为双击 todo 添加一个 editTodo 方法，这个方法把编辑前的 todo 状态暂存到 editedTodo。双击事件为 dblclick：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">      &lt;span :class=&quot;&#123;finished: todo.finished&#125;&quot; </span><br><span class="line">            @dblclick=&quot;editTodo(todo)&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">      ...</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let id = 0; // 用于 id 生成</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">            editTodo: function (todo) &#123;</span><br><span class="line">                this.editedTodo = &#123;id: todo.id, title: todo.title&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>特别注意这里我们使用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.editedTodo = &#123;id: todo.id, title: todo.title, finished: todo.finished&#125;</span><br></pre></td></tr></table></figure>
<p>而不是简单的 this.editedTodo=todo 进行复制，因为这样做的话仅仅只是将对 todo 的引用存到 this.editedTodo，这样的话任何对 todo 的修改都会反映到 editedTodo 上，为了防止这种情况，我们要为 editedTodo 创建一个全新的对象。</p>
<p>打开浏览器刷新，多创建几条 todo（一定要多创建几条），然后双击 todo 的标题，你会发现…</p>
<p>好吧，这并不符合我们的预期，我们希望双击哪条todo，哪条 todo 对应的编辑框弹出来，而不是所有的都弹出来。仔细分析一下我们的代码，我们根据 this.editedTodo !==null 来决定是否显示编辑框，而当某条 todo 被编辑时，this.editedTodo !==null 不再成立，所以所有编辑框都出现了，怎么解决这个问题呢？</p>
<p>只有在被编辑的 todo 的 id 和被暂存的 editedTodo 的 id 相等时，才表示这条 todo 在编辑，而其它的 todo 的 id 和 editedTodo 的 id 都是不相等的，所以我们可以加一个判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">        &lt;span :class=&quot;&#123;finished: todo.finished&#125;&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;删除&quot; @click=&quot;removeTodo&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&quot;编辑 todo...&quot;</span><br><span class="line">               v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>要注意 Vue 允许我们在指令中写入任何合法的 javascript 表达式，Vue 会自动对其求值。</p>
<p>然后我们将编辑框的值和 todo 的 title 值双向绑定，那么 todo 的 title 就会跟着编辑框输入的值来变化了，我们也不用担心用户改变了 todo 的 title 值，因为我们已经把编辑前的 todo 的状态暂存到了 editedTodo，想反悔可以随时还原。表单绑定用 v-model：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;编辑 todo...&quot;</span><br><span class="line">           v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br><span class="line">           v-model=&quot;todo.title&quot;/&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>然后就是用户敲击回车，编辑完成，这里我们给编辑框绑定了一个 keyup 方法监听键盘事件，enter 是修饰符，表示这个键盘事件是按下回车，此时会调用 editDone 方法。用户按下回车后因为 todo.title 的值本身就是随着编辑框输入的值变化的，所以我们基本不用做什么事情，如果用户编辑已经完成，暂存的 todo 就不再需要了，我们可以简单地把 editedTodo 还原成 null，这样编辑框的 v-if 判断就会失效，编辑框自动隐藏，完美！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;编辑 todo...&quot;</span><br><span class="line">           v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br><span class="line">           v-model=&quot;todo.title&quot;</span><br><span class="line">           @keyup.enter=&quot;editDone(todo)&quot;/&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let id = 0; // 用于 id 生成</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">            editDone: function (todo) &#123;</span><br><span class="line">                this.editedTodo = null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>取消怎么办呢？取消就是把已经编辑修改的 todo 标题还原，我们的原始信息存在 editedTodo，取出来即可。用户按键盘的 ESC 键进行取消编辑，为此绑定一个键盘事件，和 enter 类似，用 esc 修饰该事件，表示按下的是 ESC 键，然后调用 cancelEdit 方法，该方法将 todo 还原成编辑前的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in todos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;编辑 todo...&quot;</span><br><span class="line">           v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br><span class="line">           v-model=&quot;todo.title&quot;</span><br><span class="line">           @keyup.enter=&quot;editDone(todo)&quot;</span><br><span class="line">           @keyup.esc=&quot;cancelEdit(todo)&quot;/&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let id = 0; // 用于 id 生成</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">            cancelEdit: function (todo) &#123;</span><br><span class="line">                todo.title = this.editedTodo.title;</span><br><span class="line">                this.editedTodo = null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意要编辑框聚焦后按 ESC 才有效。</p>
<p>同样因为用户编辑已经取消，todo 状态已经还原，暂存的 todo 也不再需要了，我们可以简单地把 editedTodo 还原成 null，这样 v-if 判断就会失效，编辑框自动隐藏。</p>
<p><strong>练习</strong></p>
<p>我们应用的体验有一点点不好的地方，如果用户把编辑的内容清空然后按回车确认修改，这时一条空的 todo 就保存了。我们认为用户清空内容就是不想要这条 todo 了，毕竟现实一条空的 todo 没有意义，所以我们应该删除掉这条 todo，实现这个需求。（hint：我们之前实现了 removeTodo 方法，就是做这个的。学会复用代码而不是重复造轮子。）</p>
<p>另外一个不爽的地方就是双击 todo 后弹出编辑框，焦点并没有自动转到编辑框，只有手动点击编辑哭后我们才能编辑内容。这个需求的实现设计到 Vue 的自定义指令功能，我们在下一节来实现。</p>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">editDone: function(todo)&#123;</span><br><span class="line">                    if(!todo.title)&#123;</span><br><span class="line">                        this.removeTodo(todo);</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.editedTodo = null;</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="自定义指令实现自动聚焦"><a href="#自定义指令实现自动聚焦" class="headerlink" title="自定义指令实现自动聚焦"></a>自定义指令实现自动聚焦</h3><p>我们希望用户双击 todo 进入编辑状态后输入框自动获取焦点，而不是需要先手动点一下。input 元素有一个 focus 方法可以来帮我们完成这个事情，但现在的问题是如何在 Vue 中获得这个 input 元素，从而来操作它。Vue 的自定义指令可以完成这个功能。</p>
<p>我们先来看看 Vue 官网的一个示例：</p>
<blockquote>
<p>然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：</p>
<p>一个输入框：</p>
<p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>
<p><code>js // 注册一个全局自定义指令</code>v-focus<code>Vue.directive(&#39;focus&#39;, { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } })</code></p>
<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<p><code>js directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } }</code></p>
</blockquote>
<p>指令是什么，就是用来指导被绑定的元素的行为，我们之前接触过 v-if、v-model、v-bind 等指令，官方文档说的非常清楚，我们可以自己注册一个指令，然后实现某些钩子函数，从而指定被绑定元素的行为。这里我们依葫芦画瓢，实现一个 focus 指令，这个指令实现了 inserted 钩子函数，这个函数在被绑定的元素被插入 dom 时触发，且被绑定的元素会作为参数传入钩子函数，我们就可以在函数中对它操作。</p>
<p>我们在 Vue 对象中声明局部指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let id = 0; // 用于 id 生成</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        directives: &#123;</span><br><span class="line">            focus: &#123;</span><br><span class="line">                inserted: function (el) &#123;</span><br><span class="line">                    el.focus()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用这个指令了，把它绑定到编辑框，这样编辑框出现时指令就被触发，从而聚焦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; </span><br><span class="line">       value=&quot;编辑 todo...&quot;</span><br><span class="line">       v-focus=&quot;true&quot;</span><br><span class="line">       v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br><span class="line">       v-model=&quot;todo.title&quot;</span><br><span class="line">       @keyup.enter=&quot;editDone(todo)&quot;</span><br><span class="line">       @keyup.esc=&quot;cancelEdit(todo)&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>注意因为元素一旦出现一定要聚焦的，所以条件始终为 true。</p>
<p>现在用户体验好多了！快打开浏览器体验一下吧！</p>
<h3 id="全部标为完成"><a href="#全部标为完成" class="headerlink" title="全部标为完成"></a>全部标为完成</h3><p>全部标为完成的实现也非常简单，我们只需监听click事件，然后将所有未完成的 todos 标为完成即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; </span><br><span class="line">           value=&quot;全部标为完成&quot; </span><br><span class="line">           @click=&quot;markAllAsCompleted&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">... </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let id = 0; // 用于 id 生成</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">            markAllAsCompleted: function () &#123;</span><br><span class="line">                this.todos.map(function (todo) &#123;</span><br><span class="line">                    if (!todo.completed) &#123;</span><br><span class="line">                        todo.completed = true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>逻辑事实上是非常清晰的，只是 <code>markAllAsCompleted</code> 里面用到了一些 js 的高级方法，即 <code>map</code> 方法。</p>
<p>map 是一种函数式编程的思想。假设我们有一个列表，我们需要对列表中的每一个元素做同样的操作，直观的方法就是遍历列表，然后依次应用这个函数到每个元素上，最后把作用后的结果返回。map 封装了这些步骤，让我们无需显示循环列表。</p>
<p>在这里我们希望将 <code>this.todos</code> 这个列表中每一个完成的 todo 标为已完成，因此我们做了：<code>this.todo.map(func)</code>，这个 func 就是每一个 todo 的操作，它的操作是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function (todo) &#123;</span><br><span class="line">    if (!todo.completed) &#123;</span><br><span class="line">        todo.completed = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即把所有未完成的 todo 的 <code>todo.completed</code> 置为 <code>true</code>。</p>
<p>组合起来就完成了我们的需求。</p>
<blockquote>
<p>ES6 还有一种箭头函数写法：</p>
<p>todo =&gt; todo.finished = true</p>
<p>实现的功能和上面那个 function 函数类似，同样能满足我们的需求，但是写法简洁了很多。箭头函数我们在后面的功能会用到，以此来简化代码，你也可以提前了解一下它，廖雪峰的教程给出了不错的讲解：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="noopener">箭头函数</a>。</p>
<p>但要注意 ES6 语法不是所有浏览器都支持，推荐使用最新版 Chrome 或者 firefox。</p>
</blockquote>
<h3 id="还剩多少todo未完成"><a href="#还剩多少todo未完成" class="headerlink" title="还剩多少todo未完成"></a>还剩多少todo未完成</h3><p>左下角显示了还有多少个 todo 没有完成，现在固定显示 3，因为我们之前在 html 页面中设置的是 3，这显然没意思。我们应该动态地根据实际未完成 todo 的数量来显示。</p>
<p>这里的关键就是计算 todos 列表中还有多少个 todo 的 <code>completed</code> 属性为 <code>false</code>，这些 todo 就是未完成的，得到这些 todo 的个数就可以了。</p>
<p>前面说过，根据 Vue 对象已有的数据来计算新的结果，就是计算属性典型的应用场景。我们来计算一下未完成 todo 的结果，然后在模板中引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span&gt;剩余 &#123;&#123;leftTodosCount&#125;&#125; 项未完成 ---&lt;/span&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    ...</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            leftTodosCount: function () &#123;</span><br><span class="line">                return this.todos.filter(todo =&gt; !todo.completed).length</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        directives: &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>看看效果！记得每次看效果前刷新浏览器。</p>
<p>这里我们用到了 <code>filter</code> 函数，<code>filter</code> 和之前讲过的 <code>map</code> 函数是类似的，都是函数式编程的思想。<code>map</code> 用于将一个函数作用于列表的所有元素，然后得到一个作用后的列表结果。<code>filter</code> 顾名思义，就是要根据某个检测函数去列表中筛选出符合检测要求的结果。通常这个函数只返回两个值，列表元素符合要求返回真，否则返回假。<code>filter</code> 会返回所有检测为真的元素组成的列表。</p>
<p>我们这里的检测函数是：<code>todo =&gt; !todo.completed</code>，等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(todo)&#123;</span><br><span class="line">    return !todo.completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即如果 <code>todo.completed</code> 为假，即 todo 未完成，返回真，已完成返回假。所以我们就把未完成的 todo 筛选出来了。</p>
<p>关于箭头函数，廖雪峰的教程 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="noopener">箭头函数</a> 讲的非常清晰，不懂的可以再系统了解一下。</p>
<blockquote>
<p>如果你熟悉 Python 或者其它一些高级语言，一般都会提供一个叫 <code>lambda</code> 的函数，这是一种匿名函数，可用于定义函数体非常简单的函数。比如 Python 的 <code>lambda x: x*x</code></p>
<p>这比写一个函数：</p>
<p><code>python def square(x): return x*x</code></p>
<p>便捷很多。</p>
</blockquote>
<h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><p>接下来就是筛选功能，有了之前筛选全部未完成的 todo 的经验，相信实现其它的筛选思路也就非常清晰了，我们这里有三种筛选：</p>
<ul>
<li>全部：显示全部 todo</li>
<li>进行中：显示未完成的 todo</li>
<li>已完成：显示已完成的 todo</li>
</ul>
<p>为了增强用户体验，选中的按钮应该高亮显示，我们这里把它标红了。</p>
<p>现在唯一的问题是，我们如何知道应该筛选出哪中类型的 todo 呢？用户是想要进行中的 todo 还是已完成的todo？可以发现用户会点击相应的按钮来表明他的意图。如果我们在用户点击按钮时把他的意图传递给 Vue 对象，Vue 就知道该怎么做了。</p>
<p>因此我们给 <code>data</code> 增加一个属性 <code>intention</code>，来记录用户的意图。我们定义三种意图：</p>
<ul>
<li>all：想查看全部 todo</li>
<li>ongoing：想查看未完成的 todo</li>
<li>completed：想查看已完成的 todo</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">        el: &apos;#todo-app&apos;,</span><br><span class="line">        data: function () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                todos: [],</span><br><span class="line">                newTodoTitle: &apos;&apos;,</span><br><span class="line">                editedTodo: null,</span><br><span class="line">                intention: &apos;all&apos;, // 默认为 all</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>然后我们需要根据用户的意图从 todos 中筛选 todo，之前说过，从 Vue 已绑定的数据中计算新的结果是计算属性的典型应用场景，所以我们加一个 <code>filteredTodos</code> 计算属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">            leftTodosCount: function () &#123;</span><br><span class="line">                return this.todos.filter(todo =&gt; !todo.finished).length</span><br><span class="line">            &#125;,</span><br><span class="line">            filteredTodos: function () &#123;</span><br><span class="line">                if (this.intention === &apos;ongoing&apos;) &#123;</span><br><span class="line">                    return this.todos.filter(todo =&gt; !todo.finished)</span><br><span class="line">                &#125; else if (this.intention === &apos;finished&apos;) &#123;</span><br><span class="line">                    return this.todos.filter(todo =&gt; todo.finished)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 其它未定义的意图我们为其返回全部 todos，</span><br><span class="line">                    // 这里面已经包含了 all 意图了</span><br><span class="line">                    return this.todos</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<p>当然我们会发现未完成的 todo 分别在 <code>filteredTodos</code> 和 <code>leftTodosCount</code> 两个计算属性中被计算了两次，为了优化一下计算效率，我们可以重构一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">            leftTodos: function () &#123;</span><br><span class="line">                return this.todos.filter(todo =&gt; !todo.finished)</span><br><span class="line">            &#125;,</span><br><span class="line">            leftTodosCount: function () &#123;</span><br><span class="line">                return this.leftTodos.length</span><br><span class="line">            &#125;,</span><br><span class="line">            filteredTodos: function () &#123;</span><br><span class="line">                if (this.flag === &apos;ongoing&apos;) &#123;</span><br><span class="line">                    return this.leftTodos</span><br><span class="line">                &#125; else if (this.flag === &apos;finished&apos;) &#123;</span><br><span class="line">                    return this.todos.filter(todo =&gt; todo.finished)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 其它未定义的意图我们为其返回全部 todos，</span><br><span class="line">                    // 这里面已经包含了 all 意图了</span><br><span class="line">                    return this.todos</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<p><code>filteredTodos</code> 就是我们根据用户意图返回的结果。</p>
<p>打开浏览器，刷新看看效果！发现怎么点击筛选按钮返回的还是全部 todo。好吧，我想你也想到了，我么只是在 vue 中定义了计算属性，但是用户点击按钮并没有把它们的意图传给 Vue 对象。我们来设置一下，让用户的意图在点击按钮时传给 Vue，这样 Vue 才知道如何操作。给各个筛选按钮绑定一个 click 事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span&gt;剩余&lt;span style=&quot;font-weight: bold;&quot;&gt; &#123;&#123;leftTodosCount&#125;&#125; &lt;/span&gt;项未完成 ---&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;筛选：</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;全部&quot;</span><br><span class="line">             class=&quot;selected&quot;</span><br><span class="line">             @click=&quot;intention=&apos;all&apos;&quot;/&gt;</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;进行中&quot;</span><br><span class="line">             @click=&quot;intention=&apos;ongoing&apos;&quot;/&gt;</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;已完成&quot;</span><br><span class="line">             @click=&quot;intention=&apos;finished&apos;&quot;/&gt;</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;清除已完成&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;清除全部&quot;&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>特别注意不要忘了 “intention=’all’” all 两边的引号，因为这是一个字符串。</p>
<p>再次打开浏览器看效果，好吧，怎么点还是没反应。忘了刷新？刷新一下，还是没反应！哪里出错了？F12 打开控制台调试，Vue 显示欢迎消息没有任何错误提示！！</p>
<p>尝试着自己找找原因~~</p>
<p>我们之前在循环显示 todo 列表时使用的是 <code>this.todos</code> 的数据，当然你无论如何点击按钮循环的始终都是 todos 的数据。把循环的内容改为 <code>filteredTodos</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in filteredTodos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">    &lt;span :class=&quot;&#123;finished: todo.finished&#125;&quot;</span><br><span class="line">          @dblclick=&quot;editTodo(todo)&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<p><strong>练习</strong></p>
<p>现在筛选的功能基本完成了，但是有一个地方还没有实现，用户点击相应意图的按钮，对应的按钮应该高亮显示，而现在始终只有全部按钮高亮，因为我们在 html 中为其设置了 <code>class</code> 始终为 <code>selected</code>。尝试修改代码实现需求。（hint：别忘了 Vue 的动态样式绑定。如何判断用户点击了哪个按钮呢？）</p>
<p>答案：</p>
<p>使用 Vue 的动态样式绑定，并且根据 <code>intention</code> 的值来决定是否需要给相应的按钮绑定样式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;筛选：</span><br><span class="line">    &lt;input type=&quot;button&quot;</span><br><span class="line">           value=&quot;全部&quot;</span><br><span class="line">           v-bind:class=&quot;&#123;selected: intention===&apos;all&apos;&#125;&quot;</span><br><span class="line">           @click=&quot;intention=&apos;all&apos;&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot;</span><br><span class="line">           value=&quot;进行中&quot;</span><br><span class="line">           v-bind:class=&quot;&#123;selected: intention===&apos;ongoing&apos;&#125;&quot;</span><br><span class="line">           @click=&quot;intention=&apos;ongoing&apos;&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot;</span><br><span class="line">           value=&quot;已完成&quot;</span><br><span class="line">           v-bind:class=&quot;&#123;selected: intention===&apos;completed&apos;&#125;&quot;</span><br><span class="line">           @click=&quot;intention=&apos;completed&apos;&quot;/&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>注意各个按钮的 <code>v-bind:class=&quot;{selected: intention===&#39;xxx&#39;}&quot;</code> ，点击哪个按钮，<code>intention</code> 就被赋予相应的值，从而被点击的按钮的 <code>class</code> 会被设置为红色。</p>
<h2 id="批量清除todo"><a href="#批量清除todo" class="headerlink" title="批量清除todo"></a>批量清除todo</h2><p>接下来还剩下最后两个清除已完成和清除全部 todo 的功能，有了如何筛选todo 的经验，清除todo也是小菜一碟，只要把筛选出来的 todo 从 todos 列表删除就可以了。</p>
<p>老套路，先为按钮绑定事件，然后实现相应的绑定方法，相信你已经轻车熟路了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;清除已完成&quot; @click=&quot;clearCompleted&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;清除全部&quot; @click=&quot;clearAll&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let id = 0; // 用于 id 生成</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        ...</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...</span><br><span class="line">            clearCompleted: function () &#123;</span><br><span class="line">                this.todos = this.todos.filter(todo =&gt; !todo.completed)</span><br><span class="line">            &#125;,</span><br><span class="line">            clearAll: function () &#123;</span><br><span class="line">                this.todos = []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>bingo！恭喜你完成了一个非常酷的，具有极简风格设计的 todo 应用！！祝贺一下自己。</p>
<p><strong>练习</strong></p>
<p>用户体验增强。</p>
<p>现在我们的 todo 应用已经非常酷了。但是还有一点用户体验需要优化。虽然我们采用极简主义风格设计，但是我们在用户体验方面绝不马虎。这是我长期使用 Google、Amazon、Facebook 等国外一流企业的应用而获得的经验和感悟。</p>
<p>当没有todo是，全部标为完成的按钮和底部的删选栏一直出现，这是没有意义的，只有有 todo 时才让它们出现。试着完成这个功能。</p>
<p>当用户的全部 todo 都完成时想，显示的依然是剩余0项未完成，这给用户的感觉不好。为什么不显示一点别的信息，比如“全部完成，你真是太优秀了”。这能增大用户使用我么产品的粘性。试着完成这个功能。</p>
<p>同样的，之前已经提过，删除功能一定要柔软，不能太粗暴。现在用户如果不小心点了清楚全部的按钮，它的所有 todo 都没了，如果这些 todo 对它很重要的话。尝试实现清楚前确认提醒。之前我们已经实现过类似的需求。此外，给用户加一个回收站功能，用户能够查看已经删除的所有todo。</p>
<p>答案：</p>
<p><strong>练习一</strong></p>
<p>非常简单，用 if 指令，根据是否存在某类型的 todo 来决定该类型的按钮显示或者隐藏即可，具体的有：</p>
<ul>
<li>如果不存在未完成的 todo，全部标为完成、进行中的按钮隐藏。</li>
<li>如果不存在已完成的 todo，已完成、清除已完成的按钮隐藏。</li>
<li>若没有 todo，筛选和清除等按钮全隐藏，显示“添加我的第一个 todo”，若不存在未完成的 todo，显示“全部完成，你真是太优秀了”，否则显示“剩余 x 项未完成”。</li>
</ul>
<p>首先增加两个计算属性，返回全部已完成的 todo 和其数量，同时顺便把 <code>filteredTodos</code> 计算属性重构一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...</span><br><span class="line">    completedTodos: function () &#123;</span><br><span class="line">        return this.todos.filter(todo =&gt; todo.completed)</span><br><span class="line">    &#125;,</span><br><span class="line">    completedTodosCount: function () &#123;</span><br><span class="line">        return this.completedTodos.length</span><br><span class="line">    &#125;,</span><br><span class="line">    filteredTodos: function () &#123;</span><br><span class="line">        if (this.intention === &apos;ongoing&apos;) &#123;</span><br><span class="line">            return this.leftTodos</span><br><span class="line">        &#125; else if (this.intention === &apos;completed&apos;) &#123;</span><br><span class="line">            return this.completedTodos</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其它未定义的意图我们为其返回全部 todos，</span><br><span class="line">            // 这里面已经包含了 all 意图了</span><br><span class="line">            return this.todos</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后根据这些计算属性判断相应按钮和文字的显示和隐藏即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-if=&quot;leftTodosCount&quot;</span><br><span class="line">       type=&quot;button&quot;</span><br><span class="line">       value=&quot;全部标为完成&quot;</span><br><span class="line">       @click=&quot;markAllAsCompleted&quot;/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-if=&quot;leftTodosCount&quot;&gt;剩余 &#123;&#123;leftTodosCount&#125;&#125; 项未完成 ---&lt;/span&gt;</span><br><span class="line">&lt;span v-else-if=&quot;completedTodosCount&quot;&gt;全部完成，你真是太优秀了！&lt;/span&gt;</span><br><span class="line">&lt;span v-else&gt;添加我的第一个todo&lt;/span&gt;</span><br><span class="line">&lt;span v-if=&quot;todos.length&quot;&gt;筛选：</span><br><span class="line">  &lt;input type=&quot;button&quot;</span><br><span class="line">         class=&quot;selected&quot;</span><br><span class="line">         value=&quot;全部&quot;</span><br><span class="line">         @click=&quot;intention=&apos;all&apos;&quot;/&gt;</span><br><span class="line">  &lt;input v-if=&quot;leftTodosCount&quot;</span><br><span class="line">         type=&quot;button&quot;</span><br><span class="line">         value=&quot;进行中&quot;</span><br><span class="line">         @click=&quot;intention=&apos;ongoing&apos;&quot;/&gt;</span><br><span class="line">  &lt;input v-if=&quot;completedTodosCount&quot;</span><br><span class="line">         type=&quot;button&quot;</span><br><span class="line">         value=&quot;已完成&quot;</span><br><span class="line">         @click=&quot;intention=&apos;completed&apos;&quot;/&gt;</span><br><span class="line">  &lt;input v-if=&quot;completedTodosCount&quot;</span><br><span class="line">         type=&quot;button&quot;</span><br><span class="line">         value=&quot;清除已完成&quot;</span><br><span class="line">         @click=&quot;clearCompleted&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot;</span><br><span class="line">         value=&quot;清除全部&quot;</span><br><span class="line">         @click=&quot;clearAll&quot;/&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p><strong>练习二</strong></p>
<p>清除时确认的功能和之前删除单个 todo 的功能类似，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clearCompleted: function () &#123;</span><br><span class="line">    if (!confirm(&apos;确认清除全部已完成的待办事项？&apos;)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    this.todos = this.todos.filter(todo =&gt; !todo.completed)</span><br><span class="line">&#125;,</span><br><span class="line">clearAll: function () &#123;</span><br><span class="line">    if (!confirm(&apos;确认清除全部待办事项？&apos;)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    this.todos = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收站的功能略微复杂，我们来逐步分析。</p>
<p>首先我们需要改造一下 todo 模型，为其增加一个 removed 属性，这个属性用于标识 todo 是否已经被删除，注意这次删除 todo 时不再是直接从 todos 数组里删除，而是将其移到回收站（增加一个回收站数组用于存放删除的 todo），removed 属性的值会给我们今后为是否删除的 todo 执行不同操作时带来诸多方便，具体修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        todos: [],</span><br><span class="line">        recycleBin: [], // 用于存放已经删除的 todo</span><br><span class="line">        newTodoTitle: &apos;&apos;,</span><br><span class="line">        editedTodo: null, // 用户暂存编辑前的 todo 状态</span><br><span class="line">        intention: &apos;all&apos;, // 默认为 all</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    addTodo: function () &#123;</span><br><span class="line">        this.todos.push(</span><br><span class="line">            // 修改后的 todo 模型</span><br><span class="line">            &#123;id: id++, title: this.newTodoTitle, completed: false, removed: false&#125;</span><br><span class="line">        );</span><br><span class="line">        this.newTodoTitle = &apos;&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>然后当我们删除 todo 或者清除 todo 时，应该把删除的 todo 插入 recycleBin 数组中，以便后续还原，即相应修改 <code>removeTodo</code> 、<code>clearAll</code> 和 <code>clearCompleted</code> 方法的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">removeTodo: function (todo) &#123;</span><br><span class="line">    let removedTodo = this.todos.splice(this.todos.indexOf(todo), 1)[0];</span><br><span class="line">    removedTodo.removed = true;</span><br><span class="line">    this.recycleBin.unshift(removedTodo);</span><br><span class="line">&#125;,</span><br><span class="line">clearCompleted: function () &#123;</span><br><span class="line">    if (!confirm(&apos;确认清除全部已完成的待办事项？&apos;)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    this.completedTodos.map(todo =&gt; todo.removed = true);</span><br><span class="line">    this.recycleBin.unshift(...this.completedTodos);</span><br><span class="line">    this.todos = this.leftTodos;</span><br><span class="line">&#125;,</span><br><span class="line">clearAll: function () &#123;</span><br><span class="line">    if (!confirm(&apos;确认清除全部待办事项？&apos;)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    this.todos.map(todo =&gt; todo.removed = true);</span><br><span class="line">    this.recycleBin.unshift(...this.todos);</span><br><span class="line">    this.todos = [];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>要注意熟悉 JavaScript 数组的插入删除等操作，具体请查看 js 的文档，这里不再详细说明。</p>
<p>然后增加一个回收站按钮，点击后进入回收站，显示全部已删除的 todo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-if=&quot;todos.length || recycleBin.length&quot;&gt;筛选：</span><br><span class="line">  ...</span><br><span class="line">  &lt;input v-if=&quot;recycleBin.length&quot;</span><br><span class="line">         type=&quot;button&quot;</span><br><span class="line">         value=&quot;回收站&quot;</span><br><span class="line">         @click=&quot;intention=&apos;removed&apos;&quot;/&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>这里回收站这个按钮和已完成、进行中等筛选按钮是类似的，它对应的 intention 是 removed，相应的要修改计算属性 <code>filteredTodos</code> 的逻辑，当 intention 为 removed 是能返回已删除的数组列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filteredTodos: function () &#123;</span><br><span class="line">    if (this.intention === &apos;ongoing&apos;) &#123;</span><br><span class="line">        return this.leftTodos</span><br><span class="line">    &#125; else if (this.intention === &apos;completed&apos;) &#123;</span><br><span class="line">        return this.completedTodos</span><br><span class="line">    &#125; else if (this.intention === &apos;removed&apos;) &#123;</span><br><span class="line">        return this.recycleBin</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 其它未定义的意图我们为其返回全部 todos，</span><br><span class="line">        // 这里面已经包含了 all 意图了</span><br><span class="line">        return this.todos</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看到回收站中的 todo 后面的按钮依然为删除，正确地应该显示为还原按钮，用于还原todo，可以根据 todo removed 属性的值来判断应该显示哪个按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in filteredTodos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">  &lt;span :class=&quot;&#123;completed: todo.completed&#125;&quot;</span><br><span class="line">        @dblclick=&quot;editTodo(todo)&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot;</span><br><span class="line">         value=&quot;标为完成&quot;</span><br><span class="line">         @click=&quot;markAsCompleted(todo)&quot;/&gt;</span><br><span class="line">  &lt;input v-if=&quot;todo.removed&quot; type=&quot;button&quot; value=&quot;还原&quot; @click=&quot;restoreTodo(todo)&quot;/&gt;</span><br><span class="line">  &lt;input v-else=&quot;todo.removed&quot; type=&quot;button&quot; value=&quot;删除&quot; @click=&quot;removeTodo(todo)&quot;/&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>还原按钮绑定了一个 <code>restoreTodo</code> 方法，来实现一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">restoreTodo: function (todo) &#123;</span><br><span class="line">    todo.removed = false;</span><br><span class="line">    this.todos.unshift(todo);</span><br><span class="line">    let pos = this.recycleBin.indexOf(todo);</span><br><span class="line">    this.recycleBin.splice(pos, 1);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，就是将已删除的 todo，从回收站数组移除，然后插入 this.todos，同时要记得将 removed 设置回 false。</p>
<p>类似的，我们还可以实现一次还原全部 todo，清空回收站的功能，其实现方法都大同小异，主要就是对 this.todos 和 recycleBin 数组的操作，请自行实现。（暂留）</p>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>还有一个问题，现在只要我们一刷新浏览器，所有todo 都没了，因为我们的数据保存在内存中，页面刷新数据就会清除。用户肯定不希望为了保存全部 todo 而不得不一直把这个浏览器页面开着。我们可以使用浏览器的 LocalStorage 来实现数据的持续性存储。这样一来只要用户不删除浏览器缓存，我们的 todo 会一直在。当然浏览器清除缓存后数据也没有了。为了更加持久化存储，我们可以使用数据库，但这里我们只是用 LocalStorage</p>
<p>我们首先来定义一个对象，用于 LocalStorage 存储和获取 todo 的相关操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var STORAGE_KEY = &apos;vue2.x-todo-tutorial&apos;;</span><br><span class="line">var todoStorage = &#123;</span><br><span class="line">    fetch: function () &#123;</span><br><span class="line">        var todos = JSON.parse(localStorage.getItem(STORAGE_KEY) || &apos;[]&apos;);</span><br><span class="line">        todos.forEach(function (todo, index) &#123;</span><br><span class="line">            todo.id = index</span><br><span class="line">        &#125;);</span><br><span class="line">        todoStorage.uid = todos.length;</span><br><span class="line">        return todos</span><br><span class="line">    &#125;,</span><br><span class="line">    save: function (todos) &#123;</span><br><span class="line">        localStorage.setItem(STORAGE_KEY, JSON.stringify(todos))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>STORAGE_KEY</code> 用来区分存储到 LocalStorage 的内容，因为 LocalStorage 中可能存储其它应用的数据，使用这个 key 用于区分。</p>
<p><code>todoStorage</code> 是一个 JavaScript 的对象，它的属性是两个方法。save 方法非常简单，即把 todos 转为 JSON 格式，然后将序列化的数据存入对应 key 为 STORAGE_KEY 的本地存储中。有存就有取，fetch 方法则从对应 STORAGE_KEY 的本地存储将之前存入的 todo 数据取出并反序列化。特别注意我们这里还为 todoStorage 对象绑定了一个 uid 属性，它的作用是后续添加 todo 时，用于确定新添加 todo 的 id。</p>
<blockquote>
<p>注意这里代码中的 localStorage 就代表了本地存储对象，在支持 HTLM5 的浏览器中会存在这个对象，直接引用即可。</p>
</blockquote>
<p>因此，每当用户打开页面时，我们因为去 LocalStorage fetch 一下存储的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        todos: todoStorage.fetch(),</span><br><span class="line">        newTodoTitle: &apos;&apos;,</span><br><span class="line">        editedTodo: null, // 用户暂存编辑前的 todo 状态</span><br><span class="line">        intention: &apos;all&apos;, // 默认为 all</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>同时，当我们添加 todo 时，由于可能已经存在从本地取出的 todo 数据，新的 todo id 不能是从 0 开始了，而应该从已有 todoStorage.uid 开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addTodo: function () &#123;</span><br><span class="line">    this.todos.push(</span><br><span class="line">        // 修改后的 todo 模型</span><br><span class="line">        &#123;id: todoStorage.uid++, title: this.newTodoTitle, completed: false&#125;</span><br><span class="line">    );</span><br><span class="line">    this.newTodoTitle = &apos;&apos;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>另外，一旦添加了新的 todo，我们应该及时将新的 todo 存到本地，防止用户不小心关闭页面而导致数据丢失，我们可以使用 Vue 的 watch 来监听用户添加 todo 的事件，即监视 this.todos 的变化，一旦改变，立即修改本地存储的 todos 的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">el: &apos;#todo-app&apos;,</span><br><span class="line">data: function () &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line">// 监测 todos 列表的变化，将变化存储到 local storage</span><br><span class="line">watch: &#123;</span><br><span class="line">    todos: &#123;</span><br><span class="line">        handler: function (todos) &#123;</span><br><span class="line">            todoStorage.save(todos)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>大功告成！还有一个问题，现在只要我们一刷新浏览器，所有todo 都没了，因为我们的数据保存在内存中，页面刷新数据就会清除。用户肯定不希望为了保存全部 todo 而不得不一直把这个浏览器页面开着。我们可以使用浏览器的 LocalStorage 来实现数据的持续性存储。这样一来只要用户不删除浏览器缓存，我们的 todo 会一直在。当然浏览器清除缓存后数据也没有了。为了更加持久化存储，我们可以使用数据库，但这里我们只是用 LocalStorage</p>
<p>我们首先来定义一个对象，用于 LocalStorage 存储和获取 todo 的相关操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var STORAGE_KEY = &apos;vue2.x-todo-tutorial&apos;;</span><br><span class="line">var todoStorage = &#123;</span><br><span class="line">    fetch: function () &#123;</span><br><span class="line">        var todos = JSON.parse(localStorage.getItem(STORAGE_KEY) || &apos;[]&apos;);</span><br><span class="line">        todos.forEach(function (todo, index) &#123;</span><br><span class="line">            todo.id = index</span><br><span class="line">        &#125;);</span><br><span class="line">        todoStorage.uid = todos.length;</span><br><span class="line">        return todos</span><br><span class="line">    &#125;,</span><br><span class="line">    save: function (todos) &#123;</span><br><span class="line">        localStorage.setItem(STORAGE_KEY, JSON.stringify(todos))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>STORAGE_KEY</code> 用来区分存储到 LocalStorage 的内容，因为 LocalStorage 中可能存储其它应用的数据，使用这个 key 用于区分。</p>
<p><code>todoStorage</code> 是一个 JavaScript 的对象，它的属性是两个方法。save 方法非常简单，即把 todos 转为 JSON 格式，然后将序列化的数据存入对应 key 为 STORAGE_KEY 的本地存储中。有存就有取，fetch 方法则从对应 STORAGE_KEY 的本地存储将之前存入的 todo 数据取出并反序列化。特别注意我们这里还为 todoStorage 对象绑定了一个 uid 属性，它的作用是后续添加 todo 时，用于确定新添加 todo 的 id。</p>
<blockquote>
<p>注意这里代码中的 localStorage 就代表了本地存储对象，在支持 HTLM5 的浏览器中会存在这个对象，直接引用即可。</p>
</blockquote>
<p>因此，每当用户打开页面时，我们因为去 LocalStorage fetch 一下存储的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        todos: todoStorage.fetch(),</span><br><span class="line">        newTodoTitle: &apos;&apos;,</span><br><span class="line">        editedTodo: null, // 用户暂存编辑前的 todo 状态</span><br><span class="line">        intention: &apos;all&apos;, // 默认为 all</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>同时，当我们添加 todo 时，由于可能已经存在从本地取出的 todo 数据，新的 todo id 不能是从 0 开始了，而应该从已有 todoStorage.uid 开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addTodo: function () &#123;</span><br><span class="line">    this.todos.push(</span><br><span class="line">        // 修改后的 todo 模型</span><br><span class="line">        &#123;id: todoStorage.uid++, title: this.newTodoTitle, completed: false&#125;</span><br><span class="line">    );</span><br><span class="line">    this.newTodoTitle = &apos;&apos;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>另外，一旦添加了新的 todo，我们应该及时将新的 todo 存到本地，防止用户不小心关闭页面而导致数据丢失，我们可以使用 Vue 的 watch 来监听用户添加 todo 的事件，即监视 this.todos 的变化，一旦改变，立即修改本地存储的 todos 的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">el: &apos;#todo-app&apos;,</span><br><span class="line">data: function () &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line">// 监测 todos 列表的变化，将变化存储到 local storage</span><br><span class="line">watch: &#123;</span><br><span class="line">    todos: &#123;</span><br><span class="line">        handler: function (todos) &#123;</span><br><span class="line">            todoStorage.save(todos)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<h2 id="组件化todo应用"><a href="#组件化todo应用" class="headerlink" title="组件化todo应用"></a>组件化todo应用</h2><p>Vue 的组件是一个可复用的 Vue 实例，组件可以有自己的数据（data），组件可以互相嵌套而形成一个树状组织结构。因为组件也是一个 Vue 的实例，因此它的创建和我们之前使用 new Vue 创建 Vue 实例非常类似。</p>
<p>Vue 引入组件的目的，就是为了复用。例如一个按钮，把和这个按钮相关的数据和操作逻辑封装到一个组件里，那么在需要的地方，引入这个组件就可以生成一个按钮，提高了代码的复用性。</p>
<p>Vue 组件，主要需要了解的是父组件如何向子组件传递数据，以及子组件如何向父组件发送消息。现在不理解没有关系，下面的教程会使用 todo 应用来向你演示这两个机制，以及我们如何在 Vue 中使用它。</p>
<p>为了简单起见，我们只演示将 todo 项组件化，这个例子已经足以说明 Vue 组件的使用方法了，整个应用的组件化将作为练习，由你自己利用教程中所学的的知识完成，具体来说，我们把这个看成一个组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&apos;todo in filteredTodos&apos; :key=&apos;todo.id&apos;&gt;</span><br><span class="line">  &lt;span :class=&quot;&#123;completed: todo.completed&#125;&quot;</span><br><span class="line">        @dblclick=&quot;editTodo(todo)&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot;</span><br><span class="line">         value=&quot;标为完成&quot;</span><br><span class="line">         @click=&quot;markAsCompleted(todo)&quot;/&gt;</span><br><span class="line">  &lt;input v-if=&quot;todo.removed&quot; type=&quot;button&quot; value=&quot;还原&quot; @click=&quot;restoreTodo(todo)&quot;/&gt;</span><br><span class="line">  &lt;input v-else=&quot;todo.removed&quot; type=&quot;button&quot; value=&quot;删除&quot; @click=&quot;removeTodo(todo)&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot;</span><br><span class="line">         value=&quot;编辑 todo...&quot;</span><br><span class="line">         v-focus=&quot;true&quot;</span><br><span class="line">         v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br><span class="line">         v-model=&quot;todo.title&quot;</span><br><span class="line">         @keyup.enter=&quot;editDone(todo)&quot;</span><br><span class="line">         @keyup.esc=&quot;cancelEdit(todo)&quot;/&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>Vue 需要一个模板来渲染组件，上面就是要渲染的模板，我们把模板写在一个类型为 text/x-template 的 script 标签里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;todo-item&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;span :class=&quot;&#123;completed: todo.completed&#125;&quot;</span><br><span class="line">          @dblclick=&quot;editTodo(todo)&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot;</span><br><span class="line">           value=&quot;标为完成&quot;</span><br><span class="line">           @click=&quot;markAsCompleted(todo)&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;删除&quot; @click=&quot;removeTodo(todo)&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;</span><br><span class="line">           value=&quot;编辑 todo...&quot;</span><br><span class="line">           v-focus=&quot;true&quot;</span><br><span class="line">           v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br><span class="line">           v-model=&quot;todo.title&quot;</span><br><span class="line">           @keyup.enter=&quot;editDone(todo)&quot;</span><br><span class="line">           @keyup.esc=&quot;cancelEdit(todo)&quot;/&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>要注意模板和上面一段 html 代码的不同，去掉了 li 标签上的 v-for 和绑定指令，因为我们这只是在定义组件，而不是像上面那样循环渲染组件。还要注意 script 标签设置了 id=”todo-item”，这将告诉 Vue 在注册组件时，如何定位渲染的模板所在位置。</p>
<p>然后我们在 Vue 中注册我们自定义的组件，使用 Vue.component 方法，第一个参数是你给这个组件起的组件名，第二个参数是一个对象，和我们 new Vue 示例时的选项非常类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;todo-item&apos;, &#123;</span><br><span class="line">    template: &apos;#todo-item&apos;,</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            editedTodo: null // 用户暂存编辑前的 todo 状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        todo: &#123;</span><br><span class="line">            type: Object,</span><br><span class="line">            required: true,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        focus: &#123;</span><br><span class="line">            inserted: function (el) &#123;</span><br><span class="line">                el.focus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data 中只有一个 editedTodo，在编辑功能中会用到，其用法和之前是一样的，只是从 Vue 实例移到了组件中。props 是一个新的对象，用来接收组件需要使用到的数据。试想，我们的 todo-item 组件需要一个 todo 模型的数据，才能渲染成一个待办事项，但这个数据从哪里来呢？答案就是通过这个 props 传递。当某个值传给 props 的时候，他就变成了组件实例的一个属性。比如这里 props 它接收一个 todo，那么当一个 todo 传给组件时，组件就多了一个 todo 属性，我们可以在组件中通过 this.todo 引用。同时，我们还设置了 todo 数据的要求，即它的类型是一个 Object，而且必须传递，不能缺省。</p>
<p>那么这个组件有哪些方法呢？以下方法是和这个组件相关的，我们从 app 这个 Vue 实例里复制过来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    markAsCompleted: function (todo) &#123;</span><br><span class="line">        todo.completed = true</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTodo: function (todo) &#123;</span><br><span class="line">        this.todos.splice(this.todos.indexOf(todo), 1)</span><br><span class="line">    &#125;,</span><br><span class="line">    editTodo: function (todo) &#123;</span><br><span class="line">        this.editedTodo = &#123;id: todo.id, title: todo.title&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    editDone: function (todo) &#123;</span><br><span class="line">        this.editedTodo = null</span><br><span class="line">    &#125;,</span><br><span class="line">    cancelEdit: function (todo) &#123;</span><br><span class="line">        todo.title = this.editedTodo.title;</span><br><span class="line">        this.editedTodo = null</span><br><span class="line">    &#125;，</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>和单个待办事项操作相关的方法我们都复制了过来，仔细观察可以发现，除了 removeTodo 这个方法外，其它方法均只涉及从 props 传递过来的 todo，而 removeTodo 这个操作则涉及到从 app 这个 Vue 实例的 data 中 todos 数组中删除数据。这里就出现了问题，组件是封闭，它无法直接访问父组件的数据，而且组件的数据流向是单向的，只能从父组件通过 props 传到子组件，那么如何使组件中的操作反应到父组件上呢？</p>
<p>我们可以通过事件向父级组件发送消息，我们可以使用如下的方法发送一个事件消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">removeTodo: function (todo) &#123;</span><br><span class="line">    this.$emit(&apos;remove-todo&apos;, todo)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>第一个是你给这个事件取得名字，同时时间还可以携带数据，这里我们把组件实例绑定的 todo 也发送了出去。</p>
<p>定义了这个组件，我们就可以在应用中使用了，将原来渲染待办事项的 html 代码替换为自定义的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- todo list --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;todo-item v-for=&quot;todo in filteredTodos&quot;</span><br><span class="line">             :todo=&quot;todo&quot;</span><br><span class="line">             :key=&quot;todo.id&quot;</span><br><span class="line">             @remove-todo=&quot;removeTodo&quot;/&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- end todo list --&gt;</span><br></pre></td></tr></table></figure>
<p>和之前的 li 元素是类似的，只是这里换成了我们自定义的组件，Vue 最终还是把 todo-item 渲染成 li 元素，因为这个组件使用的模板就是那个 li 元素。</p>
<p>和 @click 一样，我们这里绑定监听了一个 remove-todo 事件，这个事件组件中点击删除按钮触发的，一旦监听到这个事件被触发，就会调用 app 这个 Vue 实例中的 removeTodo 方法（注意不是组件 todo-item 中的 removeTodo 方法），因为只有在 app 这个 Vue 实例中才能访问到 todos 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#todo-app&apos;,</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            todos: todoStorage.fetch(),</span><br><span class="line">            newTodoTitle: &apos;&apos;,</span><br><span class="line">            intention: &apos;all&apos;, // 默认为 all</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...</span><br><span class="line">        removeTodo: function (todo) &#123;</span><br><span class="line">            this.todos.splice(this.todos.indexOf(todo), 1)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要注意 app 这个实例中 data 对象有一个 editedTodo 属性，这个属性移到了组件中，所以被删除了，同时所有移到组件中的方法也删除了。</p>
<p>同样的，在组件中也可以定义计算属性，举个例子，为了决定编辑框是否显示，我们使用了如下的判断表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-if=&quot;editedTodo!==null &amp;&amp; editedTodo.id===todo.id&quot;</span><br></pre></td></tr></table></figure>
<p>我们可以把这个表达式定义成组件中的一个计算属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    editing: function () &#123;</span><br><span class="line">        return this.editedTodo !== null &amp;&amp; this.editedTodo.id === this.todo.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>让后在组件模板中引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">       value=&quot;编辑 todo...&quot;</span><br><span class="line">       v-focus=&quot;true&quot;</span><br><span class="line">       v-if=&quot;editing&quot;</span><br><span class="line">       v-model=&quot;todo.title&quot;</span><br><span class="line">       @keyup.enter=&quot;editDone(todo)&quot;</span><br><span class="line">       @keyup.esc=&quot;cancelEdit(todo)&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>至此，我们应用的组件化示例就完成了。</p>
<p>尽管这是一个刻意设计的例子，组件的划分也不一定合理，但通过这个例子很好地演示了父组件到子组件的数据传递方式以及子组件通过事件向父组件传递消息的方式。把这两点牢记在心，然后把整个应用都组件化吧！这个任务就交给你了，把之前学到的东西都用起来，另外 Vue 的官方文档更是你遇到问题时最为权威的参考资料，不要忘了它！</p>
<p>教程至此全部结束，请期待后续 Vue HackerNews 项目的教程，以及 webpack 前端工程化的实践教程，感谢阅读！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xghijk.github.io/hexo/2019/03/25/vue/" data-id="cju3s1cia0009j49xxrikdkd7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexo/tags/first/">first</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/hexo/2019/04/05/file-protocol/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          file-protocol
        
      </div>
    </a>
  
  
    <a href="/hexo/2019/03/24/makeTheme/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">makeTheme</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/hexo/tags/first/">first</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo/tags/protocol/">protocol</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/hexo/tags/first/" style="font-size: 20px;">first</a> <a href="/hexo/tags/protocol/" style="font-size: 10px;">protocol</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexo/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hexo/2019/04/05/file-protocol/">file-protocol</a>
          </li>
        
          <li>
            <a href="/hexo/2019/03/25/vue/">vue</a>
          </li>
        
          <li>
            <a href="/hexo/2019/03/24/makeTheme/">makeTheme</a>
          </li>
        
          <li>
            <a href="/hexo/2019/03/23/first-hexo/">first-hexo</a>
          </li>
        
          <li>
            <a href="/hexo/2019/03/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/hexo/" class="mobile-nav-link">Home</a>
  
    <a href="/hexo/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/hexo/fancybox/jquery.fancybox.css">
  <script src="/hexo/fancybox/jquery.fancybox.pack.js"></script>


<script src="/hexo/js/script.js"></script>



  </div>
</body>
</html>